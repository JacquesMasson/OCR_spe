%\documentclass[a4paper,12pt]{article}
\documentclass[a4paper,12pt]{extarticle}

\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}  %Pour utiliser les lettres accentuées
\usepackage[table]{xcolor}
\usepackage{graphicx}
\usepackage{float}       
%\usepackage{geometry}
\usepackage[left=4cm,right=3cm,top=2cm,bottom=2.5cm]{geometry}
\usepackage{vmargin}
\usepackage{fancyhdr}
\usepackage{epsfig}
\usepackage{eurosym}
\usepackage{url}
\graphicspath{ {figures/} }
\usepackage{array}
\usepackage{listings}


\newenvironment{Times}{\fontfamily{ptm}\selectfont}{}
\fancyhf{}
\pagestyle{fancy}
\fancyhead[LO,RE]{\leftmark}
\fancyhead[LE,RO]{\rightmark}
\fancyfoot[R]{\thepage}
\fancyfoot[LO,RE]{Trust us, we have Adaboost}
\usepackage{setspace}
\setstretch{1.5}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
}

\lstdefinestyle{customasm}{
  belowcaptionskip=1\baselineskip,
  frame=L,
  xleftmargin=\parindent,
  language=[x86masm]Assembler,
  basicstyle=\footnotesize\ttfamily,
  commentstyle=\itshape\color{purple!40!black},
}

\lstset{escapechar=@,style=customc}

\title{\underline{\textbf{\begin{Huge}Rapport de soutenance 1\end{Huge}}}\\\vspace{1cm}\begin{huge}
    \textbf{Textomaton}
  \end{huge}\\
    %%\includegraphics[width=6cm]{Lacyga_+_Pig.png}\\
    \begin{LARGE} par Trust us, we have Adaboost \end{LARGE}}
  \author{\vspace{0.5cm}\\
      Corentin \bsc{Vigourt} (vigour\_b)\textit{Chef de groupe}\\
    Matthieu \bsc{Moatti} (moatti\_m) \\  
    Tom  \bsc{Moulard} (moular\_b)\\
        Noé \bsc{Delarminat} (delarm\_n)}
    \date{}
    
        
        


\begin{document}

\maketitle
\begin{center}

\vspace{1cm}
\date{31 octobre 2016}
\vspace{2cm}\\
\end{center}  
  \thispagestyle{empty}

\newpage{}

\tableofcontents
\thispagestyle{empty}

\newpage
\section*{Introduction}
\newpage

\section{Traitement de l'image}
\subsection{Ouvrir l'image}
Le but de ce projet étant de lire le texte dans une image, le point de départ est d'ouvrir l'image.
Pour cela, on a utilisé SDL afin de récupérer la valeur RGB de chacun des pixels de l'image. Pour le moment, nous ne lisons que les BMP car ils contiennent dans leurs headers leurs tailles à la différence des JPEG. Noé a codé un script qui nous permet de récupérer les tailles d'un fichier BMP en parcourant son header.
\newline
Pour la suite, on stocke l'ensemble de l'image dans un nouveau type, une Pixel *matrix qui est une matrice de Pixel.
\begin{lstlisting}
typedef struct _Pixel{
    Uint8 r;
    Uint8 g;
    Uint8 b;
}Pixel;

typedef struct _PixelMatrix{
    size_t lines;
    size_t cols;
    Pixel *data;
}PixelMatrix;
\end{lstlisting}
\subsection{Conversion en niveau de gris}
\subsection{Méthode d'Otsu}
\newpage

\section{Reconnaissance de caractères}
\subsection{Algorithme basique}
L'algorithme basique est utile afin de découper facilement des lettres dans une image composée uniquement de texte, celui-ci sera ainsi pratique pour apprendre plus rapidement au réseau de neurone.\\
Ainsi on parcourt une image binarisée pixel par pixel, lorsque l'on rencontre un pixel noir on applique l'algorithme suivant: \\
\begin{enumerate}
\item On passe le pixel courant en blanc.\\
\item On génère la liste des pixels noirs dans une zone prédéfinie autour du pixel courant.\\\\
-Tant que la liste n'est pas vide:\\
-On applique l'algorithme récursivement sur le premier élément de la liste.\\
-On génère à nouveau la liste des pixels voisins.\\
\\
\end{enumerate}
\newpage
\subsection{Le XY-cut récursif}
Cet algorithme permet de découper un texte en différents blocks tout en gardant l'ordre de lecture 

%BEGIN My work

\newpage
\section{Réseau de Neurones}
\subsection{Introduction}

Pour cette première soutenance, nous avons mis en place un réseau de neurones capables d'apprendre.\\
En effet, l'implémentation du réseau suit la description présente sur ce site web : \url{http://neuralnetworksanddeeplearning.com/}, il est capable d'apprendre et d'évoluer en fonction des résultats qu'il fournit. 
Ce réseau est modulaire et permet de gérer plusieurs formes de données : c'est-à-dire, permet de détecter, en fonction de la forme du réseau, une image pour détecter un visage, une forme et donc une lettre, ou alors, deux entrées binaires pour effectuer une fonction. 
Nous avons fait en sorte que le réseau ait une forme facilement interchangeable, pour pouvoir passer facilement entre les différentes fonctions du réseau.

\subsection{L'apprentissage}

Pour cette première version, nous avons focalisé le développement sur un calcul de XOR. 
Le réseau doit donc avoir deux entrées binaires, trois neurones pour effectuer le calcul, et enfin un neurone sur lequel on peut lire la valeur de sortie.
Ce mode de fonctionnement est très utile pour générer de grands exemples sur lesquels le réseau se base pour se régler. 
Pour générer ces exemples, il suffit de générer aléatoirement un couple de valeurs binaires qui vont servir pour les neurones en entrée, et un calcul sur ses valeurs avec une fonction mathématique XOR, qui permet d'avoir une valeur juste à comparer avec la valeur du neurone de sortie.

\begin{lstlisting}
typedef struct Bashint Bashint;
struct Bashint{
  double *input;
  double  res;
};
\end{lstlisting}

Le réseau va donc regarder les deux valeurs d'entrée (ici input) et calculer la valeur de sortie. 
En comparant cette valeur avec le vrai résultat donné par la fonction mathématique (ici res), le réseau est capable, en utilisant la méthode de la descente de gradient stochastique, de se réajuster pour donner de meilleures valeurs.


\subsection{L'utilisation}

Le réseau de neurones n'est pas user friendly, c'est-à-dire que ce n'est pas à l'utilisateur de l'utiliser directement.
Nous allons donc mettre en relation le découpage de caractère décrit un peu plus tôt et le réseau.
Le réseau va devoir recevoir une image contenant uniquement une lettre et doit en extraire le caractère.
À ce stade de développement, il n'est pas encore entièrement utilisable, mais permet déja d'effectuer la fonction xor.


%END My work


\end{document}